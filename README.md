# Cryptum Adaptive Pairs Trading Backtest System

This repository implements a complete quantitative workflow to search for historically stable cointegration periods between two assets and backtest a mean-reversion pairs trading strategy on those periods. 

The core focus is on automated discovery of robust trading windows instead of arbitrarily choosing fixed backtest intervals. 
---

## 1. Strategy Overview

The system implements a **pairs trading / statistical arbitrage** strategy based on **cointegration** between two assets (e.g., `BTC-USD` and `ETH-USD`).

Key ideas:

- Use the **Engle–Granger cointegration test** to detect pairs and periods where the price relationship is statistically stable. 
- Estimate a **static hedge ratio** via linear regression (OLS) to construct a market-neutral spread. 
- Focus trading only on **historical windows with strong cointegration and correlation**, instead of using the full time series blindly. 
- Run systematic backtests across multiple selected periods and compare performance against a simple buy-and-hold benchmark. 

The end result is a framework to evaluate when a pairs trading strategy is more or less likely to be structurally robust. 

---

## 2. Data Flow and Processing

The project separates the workflow into two main components: a **cointegration scanner** and a **multi-period backtester**. 

### 2.1 Cointegration Scanner

The `CointegrationScanner` is responsible for: 

- **Data download**  
  - Uses `yfinance` to download historical price data for the selected tickers.   
  - Works with one or more tickers and extracts the **Close** prices into a clean `DataFrame`.   
  - Optionally converts prices to **log-prices** to stabilize variance.

- **Rolling window scan**  
  - Iterates over multiple window sizes (e.g., 90, 180, 252, 360, 504 days) with a configurable step size (e.g., 30 days).  
  - For each rolling window, runs the **Engle–Granger cointegration test** using `statsmodels.coint`.
  - If cointegration is detected (p-value below a given significance level), stores:  
    - `start_date`, `end_date`, `duration_days`  
    - `pvalue`, `correlation`, `hedge_ratio`, `score`  
    - A **quality_score** that combines p-value and correlation.

- **Merging intersecting periods**  
  - Many cointegrated windows can overlap in time. 
  - The scanner groups **overlapping intervals** and merges them into larger, aggregated periods.  
  - For each merged period, it computes:  
    - Extreme dates (earliest start, latest end)  
    - Average p-value, correlation, hedge ratio, quality score  
    - Number of original windows merged and their window size composition.
  - This reduces redundancy and produces a cleaner set of **candidate trading regimes**.

- **Ranking and selection**  
  - All (merged) periods are sorted by `quality_score` in descending order. 
  - Helper methods like `get_best_periods(top_n)` and `print_best_periods()` allow quick inspection of the most promising windows.
  - A stability analysis summarizes average p-value, correlation, duration and window size distribution.

The scanner can export periods to a CSV file (e.g., `cointegration_periods_BTC-USD_ETH-USD.csv`) for later use in backtesting. 

### 2.2 Multi-Period Backtester

The **backtesting** component (e.g., `MultiPeriodBacktester`) consumes the periods generated by the scanner and evaluates the trading strategy across each window. 

Main responsibilities: 

- Load the CSV with cointegrated periods and convert rows into a standardized format:  
  `{'start': 'YYYY-MM-DD', 'end': 'YYYY-MM-DD', 'name': 'Window ...'}`. 
- For each period:
  - Download asset data for the period.  
  - Construct and trade the pairs strategy (spread-based, using the hedge ratio).  
  - Compute performance metrics: total return, Sharpe ratio, max drawdown, number of trades, win rate, and outperformance vs. buy-and-hold. 
- Print a **consolidated summary table** comparing all periods, plus aggregated statistics (average return, average Sharpe, average drawdown, etc.). 

This design allows you to run dozens of backtests in a single pass and analyze where the strategy is structurally stronger. 

---

## 3. Knowledge and Tools Used

Implementing this project required a combination of **quantitative finance**, **time series analysis**, and **software engineering** skills:

- **Quantitative finance / econometrics**
  - Concept of **cointegration** and mean-reversion spreads. 
  - Engle–Granger test and interpretation of **p-values**. 
  - Use of **correlation** and **hedge ratios** in pairs trading. 
  - Understanding of backtesting pitfalls and regime-based analysis. 

- **Time series and statistics**
  - Working with log-prices, rolling windows, and overlapping intervals. 
  - Designing a **quality score** that combines p-value and correlation into a single metric. 

- **Python and data stack**
  - `pandas` and `numpy` for time series manipulation and numerical operations. 
  - `yfinance` for data acquisition.
  - `statsmodels` for the cointegration test.
  - Clean modular code with classes like `CointegrationTester`, `CointegrationScanner` and the multi-period backtesting engine. 

- **Backtesting and performance analytics**
  - Construction of structured `BacktestResult` objects (period, return, Sharpe, max drawdown, trades, win rate, outperformance flag).
  - Aggregation and reporting across many periods, including summary tables and global statistics.

---

## 4. Possible Future Improvements

There are several directions to extend and improve this project: 

- Dynamic hedge ratio
  - Replace static OLS hedge ratio with a rolling or Kalman filter–based estimate.
  - Allow time-varying spreads and potentially better risk control. 

- More robust statistical filters
  - Add additional diagnostics (ADF tests on the spread, half-life estimation, Hurst exponent).
  - Introduce stricter filters for regime selection beyond just p-value and correlation.

- Execution and transaction costs
  - Incorporate realistic trading costs, slippage, and liquidity constraints.
  - Analyze strategy robustness after fees. 

- Position sizing and risk management
  - Implement volatility-based sizing, stop-loss / take-profit rules, and maximum leverage constraints.
  - Add portfolio-level risk metrics across multiple pairs.

- Visualization and reporting
  - Generate automatic plots for each period (equity curve, spread, z-score, drawdown).
  - Export reports to HTML or notebooks for easier analysis.

- Multi-asset and portfolio extension
  - Scan larger universes of assets to automatically discover the best pairs.
  - Build a portfolio of pairs trades instead of a single pair. 

This repository can serve as a foundation for more advanced statistical arbitrage research, both in traditional markets and in crypto. 
